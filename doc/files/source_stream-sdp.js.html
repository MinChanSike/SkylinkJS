<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SkylinkJS 0.6.15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" />JS<small>Version: 0.6.15</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.com.sg/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.com.sg/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.com.sg/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="http://developer.temasys.com.sg/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.com.sg/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/stream-sdp.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Stores the preferred sending Peer connection streaming audio codec.
 * @attribute _selectedAudioCodec
 * @type String
 * @default &quot;auto&quot;
 * @private
 * @for Skylink
 * @since 0.5.10
 */
Skylink.prototype._selectedAudioCodec = &#x27;auto&#x27;;

/**
 * Stores the preferred sending Peer connection streaming video codec.
 * @attribute _selectedVideoCodec
 * @type String
 * @default &quot;auto&quot;
 * @private
 * @for Skylink
 * @since 0.5.10
 */
Skylink.prototype._selectedVideoCodec = &#x27;auto&#x27;;

/**
 * Stores the flag if ulpfec and red codecs should be removed.
 * @attribute _disableVideoFecCodecs
 * @type Boolean
 * @default false
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._disableVideoFecCodecs = false;

/**
 * Stores the flag if CN (Comfort Noise) codec should be removed.
 * @attribute _disableComfortNoiseCodec
 * @type Boolean
 * @default false
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._disableComfortNoiseCodec = false;

/**
 * Function that modifies the session description to configure settings for OPUS audio codec.
 * @method _addSDPOpusConfig
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._addSDPOpusConfig = function(targetMid, sessionDescription) {
  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var payload = null;
  var settings = {
    stereo: false,
    useinbandfec: null,
    usedtx: null,
    maxplaybackrate: null
  };
  var audioSettings = this.getPeerInfo().settings.audio;

  if (audioSettings &amp;&amp; typeof audioSettings === &#x27;object&#x27;) {
    settings.stereo = audioSettings.stereo === true;
    settings.useinbandfec = typeof audioSettings.useinbandfec === &#x27;boolean&#x27; ? audioSettings.useinbandfec : null;
    settings.usedtx = typeof audioSettings.usedtx === &#x27;boolean&#x27; ? audioSettings.usedtx : null;
    settings.maxplaybackrate = typeof audioSettings.maxplaybackrate === &#x27;number&#x27; ? audioSettings.maxplaybackrate : null;
  }

  log.debug([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Received OPUS config -&gt;&#x27;], settings);

  // Find OPUS RTPMAP line
  for (var i = 0; i &lt; sdpLines.length; i++) {
    if (sdpLines[i].indexOf(&#x27;a=rtpmap:&#x27;) === 0 &amp;&amp; (sdpLines[i].toLowerCase()).indexOf(&#x27;opus/48000&#x27;) &gt; 0) {
      payload = (sdpLines[i].split(&#x27; &#x27;)[0] || &#x27;&#x27;).split(&#x27;:&#x27;)[1] || null;
      break;
    }
  }

  if (!payload) {
    log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Failed to find OPUS payload. Not configuring options.&#x27;]);
    return sessionDescription.sdp;
  }

  // Set OPUS FMTP line
  for (var j = 0; j &lt; sdpLines.length; j++) {
    if (sdpLines[j].indexOf(&#x27;a=fmtp:&#x27; + payload) === 0) {
      var opusFmtpLines = (sdpLines[j].split(&#x27;a=fmtp:&#x27; + payload)[1] || &#x27;&#x27;).replace(/\s/g).split(&#x27;;&#x27;);

      for (var k = 0; k &lt; opusFmtpLines.length; k++) {
        if (opusFmtpLines[k] === &#x27;useinbandfec=1&#x27; &amp;&amp; settings.useinbandfec === null) {
          log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
            &#x27;Received OPUS useinbandfec as true by default.&#x27;]);
          settings.useinbandfec = true;

        } else if (opusFmtpLines[k] === &#x27;usedtx=1&#x27; &amp;&amp; settings.usedtx === null) {
          log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
            &#x27;Received OPUS usedtx as true by default.&#x27;]);
          settings.usedtx = true;

        } else if (opusFmtpLines[k].indexOf(&#x27;maxplaybackrate&#x27;) === 0 &amp;&amp; settings.maxplaybackrate === null) {
          var maxplaybackrateVal = parseInt(opusFmtpLines[k].split(&#x27;=&#x27;)[1] || &#x27;0&#x27;, 10);

          if (maxplaybackrateVal &gt; 0) {
            log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
              &#x27;Received OPUS usedtx as &#x27; + maxplaybackrateVal + &#x27; by default.&#x27;]);
            settings.maxplaybackrate = maxplaybackrateVal;
          }
        }
      }

      log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Setting OPUS config -&gt;&#x27;], settings);

      var updatedOpusConfig = &#x27;&#x27;;

      if (settings.stereo === true) {
        updatedOpusConfig += &#x27;stereo=1;&#x27;;
      }

      if (settings.useinbandfec === true) {
        updatedOpusConfig += &#x27;useinbandfec=1;&#x27;;
      }

      if (settings.usedtx === true) {
        updatedOpusConfig += &#x27;usedtx=1;&#x27;;
      }

      if (settings.maxplaybackrate) {
        updatedOpusConfig += &#x27;maxplaybackrate=&#x27; + settings.maxplaybackrate + &#x27;;&#x27;;
      }

      sdpLines[j] = &#x27;a=fmtp:&#x27; + payload + &#x27; &#x27; + updatedOpusConfig;
      break;
    }
  }

  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that modifies the session description to limit the maximum sending bandwidth.
 * Setting this may not necessarily work in Firefox.
 * @method _setSDPBitrate
 * @private
 * @for Skylink
 * @since 0.5.10
 */
Skylink.prototype._setSDPBitrate = function(targetMid, sessionDescription) {
  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var parseFn = function (type, bw) {
    if (!(typeof bw === &#x27;number&#x27; &amp;&amp; bw &gt; 0)) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Not limiting &quot;&#x27; + type + &#x27;&quot; bandwidth&#x27;]);
      return;
    }

    var mLineType = type;

    if (type === &#x27;data&#x27;) {
      mLineType = &#x27;application&#x27;;
    }

    for (var i = 0; i &lt; sdpLines.length; i++) {
      if (sdpLines[i].indexOf(&#x27;m=&#x27; + mLineType) === 0) {
        log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
          &#x27;Limiting maximum sending &quot;&#x27; + type + &#x27;&quot; bandwidth -&gt;&#x27;], bw);

        sdpLines.splice(i + 1, 0, window.webrtcDetectedBrowser === &#x27;firefox&#x27; ?
          &#x27;b=TIAS:&#x27; + (bw * 1024) : &#x27;b=AS:&#x27; + bw);
        return;
      }
    }
  };

  parseFn(&#x27;audio&#x27;, this._streamsBandwidthSettings.audio);
  parseFn(&#x27;video&#x27;, this._streamsBandwidthSettings.video);
  parseFn(&#x27;data&#x27;, this._streamsBandwidthSettings.data);

  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that modifies the session description to set the preferred audio/video codec.
 * @method _setSDPCodec
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._setSDPCodec = function(targetMid, sessionDescription) {
  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var parseFn = function (type, codec) {
    if (codec === &#x27;auto&#x27;) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Not preferring any codec for &quot;&#x27; + type + &#x27;&quot; streaming. Using browser selection.&#x27;]);
      return;
    }

    var payload = null;

    // Find the codec first
    for (var i = 0; i &lt; sdpLines.length; i++) {
      if (sdpLines[i].indexOf(&#x27;a=rtpmap:&#x27;) === 0 &amp;&amp; (sdpLines[i].toLowerCase()).indexOf(codec.toLowerCase()) &gt; 0) {
        payload = sdpLines[i].split(&#x27;:&#x27;)[1].split(&#x27; &#x27;)[0];
      }
    }

    if (!payload) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Not preferring &quot;&#x27; +
        codec + &#x27;&quot; for &quot;&#x27; + type + &#x27;&quot; streaming as payload is not found.&#x27;]);
      return;
    }

    for (var j = 0; j &lt; sdpLines.length; j++) {
      if (sdpLines[j].indexOf(&#x27;m=&#x27; + type) === 0) {
        log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Preferring &quot;&#x27; +
          codec + &#x27;&quot; for &quot;&#x27; + type + &#x27;&quot; streaming.&#x27;]);

        var parts = sdpLines[j].split(&#x27; &#x27;);

        if (parts.indexOf(payload) &gt; 2) {
          parts.splice(payload, 1);
        }

        // Example: m=audio 9 UDP/TLS/RTP/SAVPF 111
        parts.splice(3, 0, payload);
        sdpLines[j] = parts.join(&#x27; &#x27;);
        break;
      }
    }
  };

  parseFn(&#x27;audio&#x27;, this._selectedAudioCodec);
  parseFn(&#x27;video&#x27;, this._selectedVideoCodec);

  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that modifies the session description to remove the previous experimental H264
 * codec that is apparently breaking connections.
 * NOTE: We should perhaps not remove it since H264 is supported?
 * @method _removeSDPFirefoxH264Pref
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._removeSDPFirefoxH264Pref = function(targetMid, sessionDescription) {
  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var experimentalLineIndex = sdpLines.indexOf(&#x27;a=fmtp:0 profile-level-id=0x42e00c;packetization-mode=1&#x27;);

  if (experimentalLineIndex &gt; -1) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Removing Firefox experimental H264 flag to ensure interopability reliability&#x27;]);
    sdpLines.splice(experimentalLineIndex, 1);
  }
  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that modifies the session description to append the MediaStream and MediaStreamTrack IDs that seems
 * to be missing from Firefox answer session description to Chrome connection causing freezes in re-negotiation.
 * @method _addSDPMediaStreamTrackIDs
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._addSDPMediaStreamTrackIDs = function (targetMid, sessionDescription) {
  if (!(this._peerConnections[targetMid] &amp;&amp; this._peerConnections[targetMid].getLocalStreams().length &gt; 0)) {
    log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Not enforcing MediaStream IDs as no Streams is sent.&#x27;]);
    return sessionDescription.sdp;
  }

  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var agent = ((this._peerInformations[targetMid] || {}).agent || {}).name || &#x27;&#x27;;
  var localStream = this._peerConnections[targetMid].getLocalStreams()[0];
  var localStreamId = localStream.id || localStream.label;

  var parseFn = function (type, tracks) {
    if (tracks.length === 0) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Not enforcing &quot;&#x27; + type + &#x27;&quot; MediaStreamTrack IDs as no Stream &quot;&#x27; + type + &#x27;&quot; tracks is sent.&#x27;]);
      return;
    }

    var trackId = tracks[0].id || tracks[0].label;
    var ssrcId = null;
    var hasReachedType = false;

    // Get SSRC ID
    for (var i = 0; i &lt; sdpLines.length; i++) {
      if (sdpLines[i].indexOf(&#x27;m=&#x27; + type) === 0) {
        if (!hasReachedType) {
          hasReachedType = true;
          continue;
        } else {
          break;
        }
      }

      if (hasReachedType &amp;&amp; sdpLines[i].indexOf(&#x27;a=ssrc:&#x27;) === 0) {
        ssrcId = (sdpLines[i].split(&#x27;:&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0] || null;

        var msidLine = &#x27;a=ssrc:&#x27; + ssrcId + &#x27; msid:&#x27; + localStreamId + &#x27; &#x27; + trackId;
        var mslabelLine = &#x27;a=ssrc:&#x27; + ssrcId + &#x27; mslabel:default&#x27;;
        var labelLine = &#x27;a=ssrc:&#x27; + ssrcId + &#x27; label:&#x27; + trackId;

        if (sdpLines.indexOf(msidLine) === -1) {
          sdpLines.splice(i + 1, 0, msidLine);
          i++;
        }

        if (sdpLines.indexOf(mslabelLine) === -1) {
          sdpLines.splice(i + 1, 0, mslabelLine);
          i++;
        }

        if (sdpLines.indexOf(labelLine) === -1) {
          sdpLines.splice(i + 1, 0, labelLine);
          i++;
        }
        break;
      }
    }
  };

  parseFn(&#x27;audio&#x27;, localStream.getAudioTracks());
  parseFn(&#x27;video&#x27;, localStream.getVideoTracks());

  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that modifies the session description to remove VP9 and H264 apt/rtx lines to prevent plugin connection breaks.
 * @method _removeH264VP9AptRtxForOlderPlugin
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._removeH264VP9AptRtxForOlderPlugin = function (targetMid, sessionDescription) {
  var removeVP9AptRtxPayload = false;
  var agent = (this._peerInformations[targetMid] || {}).agent || {};

  if (agent.pluginVersion) {
    // 0.8.870 supports
    var parts = agent.pluginVersion.split(&#x27;.&#x27;);
    removeVP9AptRtxPayload = parseInt(parts[0], 10) &gt;= 0 &amp;&amp; parseInt(parts[1], 10) &gt;= 8 &amp;&amp;
      parseInt(parts[2], 10) &gt;= 870;
  }

  // Remove rtx or apt= lines that prevent connections for browsers without VP8 or VP9 support
  // See: https://bugs.chromium.org/p/webrtc/issues/detail?id=3962
  if ([&#x27;chrome&#x27;, &#x27;opera&#x27;].indexOf(window.webrtcDetectedBrowser) &gt; -1 &amp;&amp; removeVP9AptRtxPayload) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Removing VP9/H264 apt= and rtx payload lines causing connectivity issues&#x27;]);

    sessionDescription.sdp = sessionDescription.sdp.replace(/a=rtpmap:\d+ rtx\/\d+\r\na=fmtp:\d+ apt=101\r\n/g, &#x27;&#x27;);
    sessionDescription.sdp = sessionDescription.sdp.replace(/a=rtpmap:\d+ rtx\/\d+\r\na=fmtp:\d+ apt=107\r\n/g, &#x27;&#x27;);
  }

  return sessionDescription.sdp;
};

/**
 * Function that modifies the session description to remove ulpfec and red codecs.
 * @method _removeUlpfecAndRedCodecs
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._removeUlpfecAndRedCodecs = function (targetMid, sessionDescription) {
  if (!this._disableVideoFecCodecs) {
    log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Enabling and not removing ulpfec or red codecs.&#x27;]);
    return sessionDescription.sdp;
  }

  var parseFn = function (codec) {
    var hasMatch = (new RegExp(&#x27;a=rtpmap:(\\d*)\\ &#x27; + codec + &#x27;.*&#x27;, &#x27;gi&#x27;)).exec(sessionDescription.sdp);

    if (!(Array.isArray(hasMatch) &amp;&amp; hasMatch.length &gt; 0)) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Not removing &quot;&#x27; + codec + &#x27;&quot; as it does not exists.&#x27;]);
      return;
    }

    for (var i = 0; i &lt; hasMatch.length; i++) {
      if (hasMatch[i].indexOf(&#x27;a=rtpmap:&#x27;) === 0) {
        continue;
      }
      var payload = parseInt(hasMatch[i] || &#x27;-1&#x27;, 10);

      if (payload &gt; -1) {
        log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
          &#x27;Removing &quot;&#x27; + codec + &#x27;&quot; payload -&gt;&#x27;], payload);

        sessionDescription.sdp = sessionDescription.sdp.replace(
          new RegExp(&#x27;a=rtpmap:&#x27; + payload + &#x27;\\ .*\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
        sessionDescription.sdp = sessionDescription.sdp.replace(
          new RegExp(&#x27;a=fmtp:&#x27; + payload + &#x27;\\ .*\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
        sessionDescription.sdp = sessionDescription.sdp.replace(
          new RegExp(&#x27;a=rtpmap:\\d+ rtx\\/\\d+\\r\\na=fmtp:\\d+ apt=&#x27; + payload + &#x27;\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
      }
    }
  };

  parseFn(&#x27;red&#x27;);
  parseFn(&#x27;ulpfec&#x27;);

  return sessionDescription.sdp;
};

/**
 * Function that modifies the session description to remove CN codecs.
 * @method _removeComfortNoiseCodec
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._removeComfortNoiseCodec = function (targetMid, sessionDescription) {
  var audioSettings = this.getPeerInfo().settings.audio;

  if (!(this._disableComfortNoiseCodec &amp;&amp; audioSettings &amp;&amp; typeof audioSettings === &#x27;object&#x27; &amp;&amp; audioSettings.stereo)) {
    log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Enabling and not removing CN codec.&#x27;]);
    return sessionDescription.sdp;
  }

  var hasMatch = /a=rtpmap:(\d*)\ CN.*/gi.exec(sessionDescription.sdp);

  if (Array.isArray(hasMatch) &amp;&amp; hasMatch.length &gt; 0) {
    for (var i = 0; i &lt; hasMatch.length; i++) {
      if (hasMatch[i].indexOf(&#x27;a=rtpmap:&#x27;) === 0) {
        continue;
      }
      var payload = parseInt(hasMatch[i] || &#x27;-1&#x27;, 10);

      if (payload &gt; -1) {
        log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Removing &quot;CN&quot; payload -&gt;&#x27;], payload);

        sessionDescription.sdp = sessionDescription.sdp.replace(
          new RegExp(&#x27;a=rtpmap:&#x27; + payload + &#x27;\\ .*\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
        sessionDescription.sdp = sessionDescription.sdp.replace(
          new RegExp(&#x27;a=fmtp:&#x27; + payload + &#x27;\\ .*\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
      }
    }
  }

  return sessionDescription.sdp;
};
    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
