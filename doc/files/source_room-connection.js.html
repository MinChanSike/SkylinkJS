<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SkylinkJS 0.6.13</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" />JS<small>Version: 0.6.13</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.com.sg/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.com.sg/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.com.sg/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="http://developer.temasys.com.sg/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.com.sg/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/room-connection.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Contains the list of Signaling action states.
 * @attribute SYSTEM_ACTION
 * @param {String} WARNING &lt;small&gt;Value &lt;code&gt;&quot;warning&quot;&lt;/code&gt;&lt;/small&gt;
 *   The action given when Signaling might be ending the User session.
 *   &lt;small&gt;See &lt;a href=&quot;#attr_SYSTEM_ACTION_REASON&quot;&gt;&lt;code&gt;SYSTEM_ACTION_REASON&lt;/code&gt;&lt;/a&gt; for the
 *     list of reasons that would result in this action state.&lt;/small&gt;
 * @param {String} REJECT &lt;small&gt;Value &lt;code&gt;&quot;reject&quot;&lt;/code&gt;&lt;/small&gt;
 *   The action state where the Signaling has ended the User session.
 *   &lt;small&gt;See &lt;a href=&quot;#attr_SYSTEM_ACTION_REASON&quot;&gt;&lt;code&gt;SYSTEM_ACTION_REASON&lt;/code&gt;&lt;/a&gt; for the
 *     list of reasons that would result in this action state.&lt;/small&gt;
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.5.1
 */
Skylink.prototype.SYSTEM_ACTION = {
  WARNING: &#x27;warning&#x27;,
  REJECT: &#x27;reject&#x27;
};

/**
 * Contains the list of reason codes for the Signaling action states given.
 * @attribute SYSTEM_ACTION_REASON
 * @param {String} FAST_MESSAGE &lt;small&gt;Value &lt;code&gt;&quot;fastmsg&quot;&lt;/code&gt;&lt;/small&gt;
 *   The reason code given when User is jamming the Signaling with a flood of messages and
 *   the Signaling might end the User session to prevent User from disrupting other Peers session.
 *  &lt;small&gt;This is caused by messages sent too quickly within less than 1 second interval from methods
 *     like &lt;a href=&quot;#method_sendMessage&quot;&gt;&lt;code&gt;sendMessage()&lt;/code&gt; method&lt;/a&gt;,
 *     &lt;a href=&quot;#method_setUserData&quot;&gt;&lt;code&gt;setUserData()&lt;/code&gt; method&lt;/a&gt;,
 *     &lt;a href=&quot;#method_muteStream&quot;&gt;&lt;code&gt;muteStream()&lt;/code&gt; method&lt;/a&gt;,
 *     &lt;a href=&quot;#method_enableAudio&quot;&gt;&lt;code&gt;enableAudio()&lt;/code&gt; method&lt;/a&gt;,
 *     &lt;a href=&quot;#method_enableVideo&quot;&gt;&lt;code&gt;enableVideo()&lt;/code&gt; method&lt;/a&gt;,
 *     &lt;a href=&quot;#method_disableAudio&quot;&gt;&lt;code&gt;disableAudio()&lt;/code&gt; method&lt;/a&gt; and
 *     &lt;a href=&quot;#method_disableVideo&quot;&gt;&lt;code&gt;disableVideo()&lt;/code&gt; method&lt;/a&gt;.
 *     However this message should not occur as queueing of messages is implemented in the SDK.&lt;/small&gt;
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;WARNING&lt;/code&gt;&lt;/small&gt;
 * @param {String} ROOM_CLOSING &lt;small&gt;Value &lt;code&gt;&quot;toClose&quot;&lt;/code&gt;&lt;/small&gt;
 *   The reason code given when User session in the Room is ending.
 *  &lt;small&gt;The starting datetime and duration of the User session depends on the type of authentication scheme used.&lt;br&gt;
 *    Read more about the different &lt;a href=&quot;http://support.temasys.com.sg/support/solutions/articles/
 * 12000002712-authenticating-your-application-key-to-start-a-connection&quot;&gt;authentication methods here&lt;/a&gt;
 *    or see the &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;WARNING&lt;/code&gt;&lt;/small&gt;
 * @param {String} CREDENTIALS_EXPIRED &lt;small&gt;Value &lt;code&gt;&quot;oldTimeStamp&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when provided credentials has already expired when User is attempting to join Room.
 *  &lt;small&gt;The starting datetime and duration of the User session depends on the type of authentication scheme used.&lt;br&gt;
 *    Read more about the different &lt;a href=&quot;http://support.temasys.com.sg/support/solutions/articles/
 * 12000002712-authenticating-your-application-key-to-start-a-connection&quot;&gt;authentication methods here&lt;/a&gt;
 *    or see the &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 * @param {String} CREDENTIALS_ERROR &lt;small&gt;Value &lt;code&gt;&quot;credentialError&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when verifying provided credentials has failed when User is attempting to join Room.
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 * @param {String} DUPLICATED_LOGIN &lt;small&gt;Value &lt;code&gt;&quot;duplicatedLogin&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when provided credentials has already been used when User is attempting to join Room.
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 * @param {String} ROOM_NOT_STARTED &lt;small&gt;Value &lt;code&gt;&quot;notStart&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when Room session has not started when User is attempting to join Room.
 *  &lt;small&gt;The starting datetime and duration of the User session depends on the type of authentication scheme used.&lt;br&gt;
 *    Read more about the different &lt;a href=&quot;http://support.temasys.com.sg/support/solutions/articles/
 * 12000002712-authenticating-your-application-key-to-start-a-connection&quot;&gt;authentication methods here&lt;/a&gt;
 *    or see the &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 * @param {String} EXPIRED &lt;small&gt;Value &lt;code&gt;&quot;expired&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when Room session has already ended when User is attempting to join Room.
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 *  &lt;small&gt;The starting datetime and duration of the User session depends on the type of authentication scheme used.&lt;br&gt;
 *    Read more about the different &lt;a href=&quot;http://support.temasys.com.sg/support/solutions/articles/
 * 12000002712-authenticating-your-application-key-to-start-a-connection&quot;&gt;authentication methods here&lt;/a&gt;
 *    or see the &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {String} ROOM_LOCKED &lt;small&gt;Value &lt;code&gt;&quot;locked&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when Room session has been locked and User is blocked from joining the Room.
 *  &lt;small&gt;Room can be unlocked with &lt;a href=&quot;#method_unlockRoom&quot;&gt;&lt;code&gt;unlockRoom()&lt;/code&gt; method&lt;/a&gt; and
 *     locked with &lt;a href=&quot;#method_lockRoom&quot;&gt;&lt;code&gt;lockRoom()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 * @param {String} ROOM_CLOSED &lt;small&gt;Value &lt;code&gt;&quot;roomclose&quot;&lt;/code&gt;&lt;/small&gt;
 *   The reason code given when User session in the Room has already ended.
 *   &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 *  &lt;small&gt;The starting datetime and duration of the User session depends on the type of authentication scheme used.&lt;br&gt;
 *    Read more about the different &lt;a href=&quot;http://support.temasys.com.sg/support/solutions/articles/
 * 12000002712-authenticating-your-application-key-to-start-a-connection&quot;&gt;authentication methods here&lt;/a&gt;
 *    or see the &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {String} SERVER_ERROR &lt;small&gt;Value &lt;code&gt;&quot;serverError&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when there has been errors while attempting to connect User to the Room.
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 * @param {String} KEY_ERROR &lt;small&gt;Value &lt;code&gt;&quot;keyFailed&quot;&lt;/code&gt;&lt;/small&gt;
 *    The reason code given when there has been errors while attempting to connect with the App Key provided in
 *    &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;.
 *  &lt;small&gt;Ties with &lt;a href=&quot;#attr_SYSTEM_ACTION&quot;&gt;&lt;code&gt;SYSTEM_ACTION&lt;/code&gt;&lt;/a&gt; action state &lt;code&gt;REJECT&lt;/code&gt;&lt;/small&gt;
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype.SYSTEM_ACTION_REASON = {
  CREDENTIALS_EXPIRED: &#x27;oldTimeStamp&#x27;,
  CREDENTIALS_ERROR: &#x27;credentialError&#x27;,
  DUPLICATED_LOGIN: &#x27;duplicatedLogin&#x27;,
  ROOM_NOT_STARTED: &#x27;notStart&#x27;,
  EXPIRED: &#x27;expired&#x27;,
  ROOM_LOCKED: &#x27;locked&#x27;,
  FAST_MESSAGE: &#x27;fastmsg&#x27;,
  ROOM_CLOSING: &#x27;toClose&#x27;,
  ROOM_CLOSED: &#x27;roomclose&#x27;,
  SERVER_ERROR: &#x27;serverError&#x27;,
  KEY_ERROR: &#x27;keyFailed&#x27;
};

/**
 * Stores the current Room name that User is connected to.
 * @attribute _selectedRoom
 * @type String
 * @private
 * @for Skylink
 * @since 0.3.0
 */
Skylink.prototype._selectedRoom = null;

/**
 * Stores the flag that indicates if Room is locked.
 * @attribute _roomLocked
 * @type Boolean
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._roomLocked = false;

/**
 * Stores the flag that indicates if User is connected to the Room.
 * @attribute _inRoom
 * @type Boolean
 * @private
 * @for Skylink
 * @since 0.4.0
 */
Skylink.prototype._inRoom = false;

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   Currently, the SDK only supports sending a single Stream to Peers.
 *   If there is &lt;a href=&quot;#method_shareScreen&quot;&gt;&lt;code&gt;shareScreen()&lt;/code&gt; Stream&lt;/a&gt; available, it will
 *   be the Stream sent to Peers regardless if &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt;
 *   Stream&lt;/a&gt; is available.
 * &lt;/blockquote&gt;
 * Function that connects User to the Room.
 * @method joinRoom
 * @param {String} [room] The Room name to connect to.
 *   &lt;small&gt;If not provided, the User will be connected to the &lt;code&gt;defaultRoom&lt;/code&gt;
 *     configured in the &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {JSON} [options] The Room connection settings.
 * @param {JSON|String} [options.userData] The User custom data.
 *   &lt;small&gt;This can be set when User is in session with &lt;a href=&quot;#method_setUserData&quot;&gt;&lt;code&gt;setUserData()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {Boolean|JSON} [options.audio] The audio settings for the Stream sent.
 *   &lt;small&gt;If either &lt;code&gt;options.audio&lt;/code&gt; or &lt;code&gt;options.video&lt;/code&gt; is defined,
 *      &lt;code&gt;joinRoom()&lt;/code&gt; would invoke &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt;
 *      method&lt;/a&gt; to retrieve a new Stream, else it will use any existing Stream if any.
 *      Additionally, if &lt;code&gt;options.video&lt;/code&gt; is not defined and this is, the &lt;code&gt;options.video&lt;/code&gt;
 *      value will be set to &lt;code&gt;false&lt;/code&gt; when retrieving the new Stream.&lt;/small&gt;
 *      &lt;small&gt;Note that unless User&#x27;s Stream is retrieved, &lt;code&gt;joinRoom()&lt;/code&gt; will not join
 *      the Room until Stream is retrieved successfully.&lt;/small&gt;
 *   &lt;small&gt;Object signature matches the &lt;code&gt;options.audio&lt;/code&gt; parameter in the
 *      &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {Boolean|JSON} [options.video] The video settings for the Stream sent.
 *   &lt;small&gt;If either &lt;code&gt;options.audio&lt;/code&gt; or &lt;code&gt;options.video&lt;/code&gt; is defined,
 *     &lt;code&gt;joinRoom()&lt;/code&gt; would invoke &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt;
 *      method&lt;/a&gt; to retrieve a new Stream, else it will use any existing Stream if any.
 *      Additionally, if &lt;code&gt;options.audio&lt;/code&gt; is not defined and this is, the &lt;code&gt;options.audio&lt;/code&gt;
 *      value will be set to &lt;code&gt;false&lt;/code&gt; when retrieving the new Stream.&lt;/small&gt;
 *      &lt;small&gt;Note that unless User&#x27;s Stream is retrieved, &lt;code&gt;joinRoom()&lt;/code&gt; will not join
 *      the Room until Stream is retrieved successfully.&lt;/small&gt;
 *   &lt;small&gt;Object signature matches the &lt;code&gt;options.video&lt;/code&gt; parameter in the
 *      &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {JSON} [options.bandwidth] &lt;blockquote class=&quot;info&quot;&gt;Note that this currently does not work
 *   with Firefox browsers.&lt;/blockquote&gt; The configuration for limiting the maximum uploading Stream bandwidth.
 * @param {Number} [options.bandwidth.audio] The maximum uploading Stream audio bandwidth.
 * @param {Number} [options.bandwidth.video] The maximum uploading Stream video bandwidth.
 * @param {Number} [options.bandwidth.data] The maximum uploading Datachannel data transfer / P2P messaging bandwidth.
 *   &lt;small&gt;Affects &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;,
 *      &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; and
 *      &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {Boolean} [options.manualGetUserMedia] The flag that indicates if &lt;code&gt;joinRoom()&lt;/code&gt; should trigger
 *   &lt;a href=&quot;#event_mediaAccessRequired&quot;&gt;&lt;code&gt;mediaAccessRequired&lt;/code&gt; event&lt;/a&gt; to allow developers to
 *   handle the retrieval of Stream using &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt; method&lt;/a&gt; or
 *   &lt;a href=&quot;#method_shareScreen&quot;&gt;&lt;code&gt;shareScreen()&lt;/code&gt; method&lt;/a&gt; as a requirement before joining the Room.
 *   &lt;small&gt;Note that unless User&#x27;s Stream is retrieved, &lt;code&gt;joinRoom()&lt;/code&gt; will not join the Room until Stream
 *      is retrieved succesfully.&lt;/small&gt;
 *   &lt;small&gt;Even if &lt;code&gt;options.audio&lt;/code&gt; or &lt;code&gt;options.video&lt;/code&gt; is defined, as long as this flag is
 *      enabled, &lt;code&gt;joinRoom()&lt;/code&gt; would not invoke &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt;
 *      method&lt;/a&gt; to retrieve a new Stream as it would leave to the developers to retrieve it.&lt;/small&gt;
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 * @param {JSON} callback.error The error result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {Error|String} callback.error.error The &lt;code&gt;joinRoom()&lt;/code&gt; error.
 * @param {Number} callback.error.errorCode The Room authentication state error code.
 *   &lt;small&gt;If error is not caused by Room authentication errors, this should not be defined&lt;/small&gt;
 *   &lt;small&gt;Sequentially, the User has to authenticate with the Platform to retrieve credentials which is
 *      used to join the Room which is known when &lt;a href=&quot;#event_systemAction&quot;&gt;&lt;code&gt;systemAction&lt;/code&gt; event&lt;/a&gt;
 *      is triggered. This error occurs when the authentication with the Platform fails.&lt;/small&gt;
 *   [Rel: Skylink.READY_STATE_CHANGE_ERROR]
 * @param {String} callback.error.room The selected Room name to connect to.
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {String} callback.success.room The selected Room name to connect to.
 * @param {String} callback.success.peerId The User&#x27;s session Peer ID in Room.
 * @param {JSON} callback.success.peerInfo The User current session information.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;peerInfo&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_peerJoined&quot;&gt;&lt;code&gt;peerJoined&lt;/code&gt; event&lt;/a&gt;.&lt;/small&gt;
 * @trigger readyStateChange, mediaAccessRequired, channelOpen, channelMessage, systemAction, peerJoined, incomingStream
 * @for Skylink
 * @since 0.5.5
 */

Skylink.prototype.joinRoom = function(room, mediaOptions, callback) {
  var self = this;
  var error;
  var stopStream = false;
  var previousRoom = self._selectedRoom;

  if (room === null) {
    error = &#x27;Invalid room name is provided&#x27;;
    log.error(error, room);

    if (typeof mediaOptions === &#x27;function&#x27;) {
      callback = mediaOptions;
      mediaOptions = undefined;
    }

    if (typeof callback === &#x27;function&#x27;) {
      callback({
        room: room,
        errorCode: self._readyState,
        error: new Error(error)
      }, null);
    }
    return;
  }
  else if (typeof room === &#x27;string&#x27;) {
    //joinRoom(room+); - skip

    //joinRoom(room+,mediaOptions+) - skip

    // joinRoom(room+,callback+)
    if (typeof mediaOptions === &#x27;function&#x27;) {
      callback = mediaOptions;
      mediaOptions = undefined;

    // joinRoom(room+, mediaOptions-)
    } else if (typeof mediaOptions !== &#x27;undefined&#x27;) {
      if (mediaOptions === null || typeof mediaOptions !== &#x27;object&#x27;) {
        error = &#x27;Invalid mediaOptions is provided&#x27;;
        log.error(error, mediaOptions);

        // joinRoom(room+,mediaOptions-,callback+)
        if (typeof callback === &#x27;function&#x27;) {
          callback({
            room: room,
            errorCode: self._readyState,
            error: new Error(error)
          }, null);
        }
        return;
      }
    }

  } else if (typeof room === &#x27;object&#x27;) {
    //joinRoom(mediaOptions+, callback);
    if (typeof mediaOptions === &#x27;function&#x27;) {
      callback = mediaOptions;
    }

    //joinRoom(mediaOptions);
    mediaOptions = room;
    room = undefined;

  } else if (typeof room === &#x27;function&#x27;) {
    //joinRoom(callback);
    callback = room;
    room = undefined;
    mediaOptions = undefined;

  } else if (typeof room !== &#x27;undefined&#x27;) {
    //joinRoom(mediaOptions-,callback?);
    error = &#x27;Invalid mediaOptions is provided&#x27;;
    log.error(error, mediaOptions);

    if (typeof mediaOptions === &#x27;function&#x27;) {
      callback = mediaOptions;
      mediaOptions = undefined;
    }

    if (typeof callback === &#x27;function&#x27;) {
      callback({
        room: self._defaultRoom,
        errorCode: self._readyState,
        error: new Error(error)
      }, null);
      return;
    }
  }

  // If no room provided, join the default room
  if (!room) {
    room = self._defaultRoom;
  }

  //if none of the above is true --&gt; joinRoom()
  var channelCallback = function (error, success) {
    if (error) {
      if (typeof callback === &#x27;function&#x27;) {
        callback({
          error: error,
          errorCode: null,
          room: self._selectedRoom
        }, null);
      }
    } else {
      if (typeof callback === &#x27;function&#x27;) {
        self.once(&#x27;peerJoined&#x27;, function(peerId, peerInfo, isSelf) {
          // keep returning _inRoom false, so do a wait
          self._wait(function () {
            log.log([null, &#x27;Socket&#x27;, self._selectedRoom, &#x27;Peer joined. Firing callback. &#x27; +
              &#x27;PeerId -&gt;&#x27;
            ], peerId);
            callback(null, {
              room: self._selectedRoom,
              peerId: peerId,
              peerInfo: peerInfo
            });
          }, function () {
            return self._inRoom;
          }, false);
        }, function(peerId, peerInfo, isSelf) {
          return isSelf;
        }, false);
      }

      self._sendChannelMessage({
        type: self._SIG_MESSAGE_TYPE.JOIN_ROOM,
        uid: self._user.uid,
        cid: self._key,
        rid: self._room.id,
        userCred: self._user.token,
        timeStamp: self._user.timeStamp,
        apiOwner: self._appKeyOwner,
        roomCred: self._room.token,
        start: self._room.startDateTime,
        len: self._room.duration,
        isPrivileged: self._isPrivileged === true, // Default to false if undefined
        autoIntroduce: self._autoIntroduce !== false, // Default to true if undefined
        key: self._appKey
      });
    }
  };

  if (self._inRoom) {
    if (typeof mediaOptions === &#x27;object&#x27;) {
      if (mediaOptions.audio === false &amp;&amp; mediaOptions.video === false) {
        stopStream = true;
        log.warn([null, &#x27;MediaStream&#x27;, self._selectedRoom, &#x27;Stopping current MediaStream &#x27; +
          &#x27;as provided settings for audio and video is false (&#x27; + stopStream + &#x27;)&#x27;], mediaOptions);
      }
    }

    log.log([null, &#x27;Socket&#x27;, previousRoom, &#x27;Leaving room before joining new room&#x27;], self._selectedRoom);

    self.leaveRoom(stopStream, function(error, success) {
      log.log([null, &#x27;Socket&#x27;, previousRoom, &#x27;Leave room callback result&#x27;], {
        error: error,
        success: success
      });
      log.log([null, &#x27;Socket&#x27;, self._selectedRoom, &#x27;Joining room. Media options:&#x27;], mediaOptions);
      if (typeof room === &#x27;string&#x27; ? room !== self._selectedRoom : false) {
        self._initSelectedRoom(room, function(errorObj) {
          if (errorObj) {
            if (typeof callback === &#x27;function&#x27;) {
              callback({
                room: self._selectedRoom,
                errorCode: self._readyState,
                error: new Error(errorObj)
              }, null);
            }
          } else {
            self._waitForOpenChannel(mediaOptions, channelCallback);
          }
        });
      } else {
        self._waitForOpenChannel(mediaOptions, channelCallback);
      }
    });

  } else {
    log.log([null, &#x27;Socket&#x27;, self._selectedRoom, &#x27;Joining room. Media options:&#x27;],
      mediaOptions);

    var isNotSameRoom = typeof room === &#x27;string&#x27; ? room !== self._selectedRoom : false;

    if (isNotSameRoom) {
      self._initSelectedRoom(room, function(errorObj) {
        if (errorObj) {
          if (typeof callback === &#x27;function&#x27;) {
            callback({
              room: self._selectedRoom,
              errorCode: self._readyState,
              error: new Error(errorObj)
            }, null);
          }
        } else {
          self._waitForOpenChannel(mediaOptions, channelCallback);
        }
      });
    } else {
      self._waitForOpenChannel(mediaOptions, channelCallback);
    }
  }
};

/**
 * Function that disconnects User from the currently connected Room and ends the User&#x27;s session.
 * @method leaveRoom
 * @param {Boolean|JSON} [stopMediaOptions=true] The flag that indicates if &lt;code&gt;leaveRoom()&lt;/code&gt;
 *   should invoke &lt;a href=&quot;#method_stopStream&quot;&gt;&lt;code&gt;stopStream()&lt;/code&gt; method&lt;/a&gt; and
 *   &lt;a href=&quot;#method_stopScreen&quot;&gt;&lt;code&gt;stopScreen()&lt;/code&gt; method&lt;/a&gt; to stop current Streams
 *   retrieved from &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt; method&lt;/a&gt; and
 *   &lt;a href=&quot;#method_shareScreen&quot;&gt;&lt;code&gt;shareScreen()&lt;/code&gt; method&lt;/a&gt;.&lt;br&gt;
 * &amp;#8594; When provided as an Boolean, it will set both &lt;code&gt;stopMediaOptions.userMedia&lt;/code&gt; and
 *    &lt;code&gt;stopMediaOptions.screenshare&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.
 * @param {Boolean} [stopMediaOptions.userMedia=true] The flag that indicates if
 *   &lt;code&gt;leaveRoom()&lt;/code&gt; should stop any currently retrieved Stream from
 *   &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt; method&lt;/a&gt;.
 * @param {Boolean} [stopMediaOptions.screenshare=true] The flag that indicates if
 *   &lt;code&gt;leaveRoom()&lt;/code&gt; should stop any currently retrieved Stream from
 *   &lt;a href=&quot;#method_shareScreen&quot;&gt;&lt;code&gt;shareScreen()&lt;/code&gt; method&lt;/a&gt;.
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 * @param {Error|String} callback.error The error result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {String} callback.success.peerId The User&#x27;s ended session Peer ID in Room.
 * @param {String} callback.success.previousRoom The Room name which User&#x27;s session has ended.
 * @trigger channelClose, streamEnded, peerLeft
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.leaveRoom = function(stopMediaOptions, callback) {
  var self = this;
  var error; // j-shint !!!
  var stopUserMedia = true;
  var stopScreenshare = true;

  // shift parameters
  if (typeof stopMediaOptions === &#x27;function&#x27;) {
    callback = stopMediaOptions;
    stopMediaOptions = true;
  } else if (typeof stopMediaOptions === &#x27;undefined&#x27;) {
    stopMediaOptions = true;
  }

  // stopMediaOptions === null or {} ?
  if (typeof stopMediaOptions === &#x27;object&#x27; &amp;&amp; stopMediaOptions !== null) {
    stopUserMedia = stopMediaOptions.userMedia !== false;
    stopScreenshare = stopMediaOptions.screenshare !== false;

  } else if (typeof stopMediaOptions !== &#x27;boolean&#x27;) {
    error = &#x27;stopMediaOptions parameter provided is not a boolean or valid object&#x27;;
    log.error(error, stopMediaOptions);
    if (typeof callback === &#x27;function&#x27;) {
      log.log([null, &#x27;Socket&#x27;, self._selectedRoom, &#x27;Error occurred. &#x27; +
        &#x27;Firing callback with error -&gt; &#x27;
      ], error);
      callback(new Error(error), null);
    }
    return;

  } else if (stopMediaOptions === false) {
    stopUserMedia = false;
    stopScreenshare = false;
  }

  if (!self._inRoom) {
    error = &#x27;Unable to leave room as user is not in any room&#x27;;
    log.error(error);
    if (typeof callback === &#x27;function&#x27;) {
      log.log([null, &#x27;Socket&#x27;, self._selectedRoom, &#x27;Error occurred. &#x27; +
        &#x27;Firing callback with error -&gt; &#x27;
      ], error);
      callback(new Error(error), null);
    }
    return;
  }

  // NOTE: ENTER/WELCOME made but no peerconnection...
  // which may result in peerLeft not triggered..
  // WHY? but to ensure clear all
  var peers = Object.keys(self._peerInformations);
  var conns = Object.keys(self._peerConnections);
  var i;
  for (i = 0; i &lt; conns.length; i++) {
    if (peers.indexOf(conns[i]) === -1) {
      peers.push(conns[i]);
    }
  }
  for (i = 0; i &lt; peers.length; i++) {
    self._removePeer(peers[i]);
  }
  self._inRoom = false;
  self._closeChannel();

  self._stopLocalMediaStreams({
    userMedia: stopUserMedia,
    screenshare: stopScreenshare
  });

  self._wait(function() {
    log.log([null, &#x27;Socket&#x27;, self._selectedRoom, &#x27;User left the room. Callback fired.&#x27;]);
    self._trigger(&#x27;peerLeft&#x27;, self._user.sid, self.getPeerInfo(), true);

    if (typeof callback === &#x27;function&#x27;) {
      callback(null, {
        peerId: self._user.sid,
        previousRoom: self._selectedRoom
      });
    }
  }, function() {
    return (Object.keys(self._peerConnections).length === 0 &amp;&amp;
      self._channelOpen === false); // &amp;&amp;
      //self._readyState === self.READY_STATE_CHANGE.COMPLETED);
  }, false);
};

/**
 * Function that locks the current Room which prevent other Peers from joining the Room.
 * @method lockRoom
 * @trigger roomLock
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype.lockRoom = function() {
  log.log(&#x27;Update to isRoomLocked status -&gt;&#x27;, true);
  this._sendChannelMessage({
    type: this._SIG_MESSAGE_TYPE.ROOM_LOCK,
    mid: this._user.sid,
    rid: this._room.id,
    lock: true
  });
  this._roomLocked = true;
  this._trigger(&#x27;roomLock&#x27;, true, this._user.sid,
    this.getPeerInfo(), true);
};

/**
 * Function that unlocks the current Room which if Room is previously lock to
 *   allow other Peers to join the Room.
 * @method unlockRoom
 * @trigger roomLock
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype.unlockRoom = function() {
  log.log(&#x27;Update to isRoomLocked status -&gt;&#x27;, false);
  this._sendChannelMessage({
    type: this._SIG_MESSAGE_TYPE.ROOM_LOCK,
    mid: this._user.sid,
    rid: this._room.id,
    lock: false
  });
  this._roomLocked = false;
  this._trigger(&#x27;roomLock&#x27;, false, this._user.sid,
    this.getPeerInfo(), true);
};

/**
 * Function that waits for Socket connection to Signaling to be opened.
 * @method _waitForOpenChannel
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._waitForOpenChannel = function(mediaOptions, callback) {
  var self = this;
  // when reopening room, it should stay as 0
  self._socketCurrentReconnectionAttempt = 0;

  // wait for ready state before opening
  self._wait(function() {
    self._condition(&#x27;channelOpen&#x27;, function() {
      mediaOptions = mediaOptions || {};

      // parse user data settings
      self._parseUserData(mediaOptions.userData || self._userData);
      self._parseBandwidthSettings(mediaOptions.bandwidth);

      // wait for local mediastream
      self._waitForLocalMediaStream(callback, mediaOptions);
    }, function() { // open channel first if it&#x27;s not opened

      if (!self._channelOpen) {
        self._openChannel();
      }
      return self._channelOpen;
    }, function(state) {
      return true;
    });
  }, function() {
    return self._readyState === self.READY_STATE_CHANGE.COMPLETED;
  });

};

    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
